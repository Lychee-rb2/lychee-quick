---
alwaysApply: true
---
# 单元测试规范

## 测试框架

使用 **vitest** 运行测试，命令：`npx vitest run`

## Mock 类型处理

为 mock 定义专用类型和辅助函数，避免使用 `any` 或 `@ts-expect-error`：

```typescript
// ❌ BAD
// eslint-disable-next-line @typescript-eslint/no-explicit-any
(Bun as any).file = mockFile;

// ✅ GOOD - 定义 mock 类型和辅助函数
interface MockedBun {
  file: ReturnType<typeof vi.fn>;
}

const setBunMock = <K extends keyof MockedBun>(
  key: K,
  value: MockedBun[K],
): void => {
  (globalThis.Bun as unknown as MockedBun)[key] = value;
};

setBunMock("file", mockFile);
```

## 异步 Mock

当 mock 异步函数时，使用 `mockResolvedValue` 或 `async` 函数：

```typescript
// ✅ GOOD
const mockModuleLoader: ModuleLoader = {
  loadMeta: vi.fn().mockResolvedValue({ help: "Test" }),
  loadHandler: vi.fn().mockResolvedValue(null),
};

// ✅ GOOD - 需要动态返回值时
loadMeta: vi.fn(async (path: string) => {
  if (path === "@/app/test/meta") return { help: "Test" };
  return null;
}),
```

## 测试结构

```typescript
describe("模块名", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("函数名", () => {
    test("should 行为描述", async () => {
      // Arrange - 准备测试数据
      // Act - 执行被测函数
      // Assert - 验证结果
    });
  });
});
```

## 覆盖率要求

目标：**100% 代码覆盖率**

- 运行覆盖率检查：`npx vitest run --coverage`
- 覆盖所有分支（if/else、switch、三元表达式）
- 覆盖所有边界条件（空数组、null、undefined）
- 覆盖所有错误处理路径（try/catch、Promise reject）

```typescript
// 确保覆盖所有分支
test("should handle empty array", () => { ... });
test("should handle null input", () => { ... });
test("should throw error when invalid", () => { ... });
```

## 难以覆盖时考虑重构

当某些代码难以测试时，**优先考虑重构代码**而非放弃覆盖率：

- **依赖注入**：将外部依赖作为参数传入，便于 mock
- **拆分函数**：将复杂逻辑拆分为可独立测试的小函数
- **提取接口**：定义接口类型，便于创建测试替身

```typescript
// ❌ BAD - 难以测试，直接依赖全局对象
function loadConfig() {
  return Bun.file("config.json").json();
}

// ✅ GOOD - 依赖注入，易于测试
function loadConfig(fileReader = Bun.file) {
  return fileReader("config.json").json();
}
```
