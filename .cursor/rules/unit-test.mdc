---
globs: */**/*.test.ts
alwaysApply: false
---
# 单元测试规范

## 测试框架

使用 **vitest** 运行测试，命令：`npx vitest run`

## Mock 类型处理

为 mock 定义专用类型和辅助函数，避免使用 `any` 或 `@ts-expect-error`：

```typescript
// ❌ BAD
// eslint-disable-next-line @typescript-eslint/no-explicit-any
(Bun as any).file = mockFile;

// ✅ GOOD - 定义 mock 类型和辅助函数
interface MockedBun {
  file: ReturnType<typeof vi.fn>;
}

const setBunMock = <K extends keyof MockedBun>(
  key: K,
  value: MockedBun[K],
): void => {
  (globalThis.Bun as unknown as MockedBun)[key] = value;
};

setBunMock("file", mockFile);
```

## 异步 Mock

当 mock 异步函数时，使用 `mockResolvedValue` 或 `async` 函数：

```typescript
// ✅ GOOD
const mockModuleLoader: ModuleLoader = {
  loadMeta: vi.fn().mockResolvedValue({ help: "Test" }),
  loadHandler: vi.fn().mockResolvedValue(null),
};

// ✅ GOOD - 需要动态返回值时
loadMeta: vi.fn(async (path: string) => {
  if (path === "@/app/test/meta") return { help: "Test" };
  return null;
}),
```

## 测试结构

```typescript
describe("模块名", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("函数名", () => {
    test("should 行为描述", async () => {
      // Arrange - 准备测试数据
      // Act - 执行被测函数
      // Assert - 验证结果
    });
  });
});
```

## 覆盖率要求

目标：**100% 代码覆盖率**

- 运行覆盖率检查：`npx vitest run --coverage`
- 覆盖所有分支（if/else、switch、三元表达式）
- 覆盖所有边界条件（空数组、null、undefined）
- 覆盖所有错误处理路径（try/catch、Promise reject）

```typescript
// 确保覆盖所有分支
test("should handle empty array", () => { ... });
test("should handle null input", () => { ... });
test("should throw error when invalid", () => { ... });
```

## 难以覆盖时考虑重构

当某些代码难以测试时，**优先考虑重构代码**而非放弃覆盖率：

- **依赖注入**：将外部依赖作为参数传入，便于 mock
- **拆分函数**：将复杂逻辑拆分为可独立测试的小函数
- **提取接口**：定义接口类型，便于创建测试替身

```typescript
// ❌ BAD - 难以测试，直接依赖全局对象
function loadConfig() {
  return Bun.file("config.json").json();
}

// ✅ GOOD - 依赖注入，易于测试
function loadConfig(fileReader = Bun.file) {
  return fileReader("config.json").json();
}
```

## 避免内存泄漏

### 全局对象恢复

修改全局对象（如 `globalThis.Bun`、`global.require`）时，必须在 `afterEach` 中恢复原始值：

```typescript
// ❌ BAD - 未恢复全局对象，导致内存泄漏
beforeEach(() => {
  globalThis.Bun.file = mockFile;
});

// ✅ GOOD - 保存并恢复原始值
const originalBunProperties: Partial<MockedBun> = {};

beforeEach(() => {
  // 保存原始属性
  if (globalThis.Bun && !originalBunProperties.file) {
    originalBunProperties.file = globalThis.Bun.file;
  }
  // 设置 mock
  globalThis.Bun.file = mockFile;
});

afterEach(() => {
  // 恢复原始属性
  if (originalBunProperties.file !== undefined) {
    globalThis.Bun.file = originalBunProperties.file;
  }
});
```

### 环境变量管理

项目通过 `@/help/env` 模块统一管理环境变量。测试时**优先使用 `vi.mock("@/help/env")` mock 整个模块**，而非 `vi.stubEnv()` 直接修改环境变量：

```typescript
// ❌ BAD - 使用 vi.stubEnv 依赖 env.ts 内部实现
beforeEach(() => {
  vi.stubEnv("MIHOMO_URL", "http://127.0.0.1:9090");
  vi.stubEnv("MIHOMO_TOKEN", "test-secret-token");
});

afterEach(() => {
  vi.unstubAllEnvs();
});

// ❌ BAD - 直接修改环境变量，测试失败时无法恢复
test("should use env var", () => {
  Bun.env.MY_VAR = "value";
});

// ✅ GOOD - mock env 模块，与 env.ts 内部实现解耦
vi.mock("@/help/env", () => ({
  MIHOMO_URL: () => "http://127.0.0.1:9090",
  MIHOMO_TOKEN: () => "test-secret-token",
}));
```

**适用场景：**

- 被测模块从 `@/help/env` 导入环境变量函数时，使用 `vi.mock("@/help/env")`
- 仅在直接测试 `env.ts` 本身时，才使用 `vi.stubEnv()` 操控 `Bun.env`

**不要测试环境变量缺失的场景：**

mock `@/help/env` 后，env 函数一定返回有效值。环境变量缺失时的校验和报错是 `env.ts` 的职责，由 `env.test.ts` 覆盖。其他模块的测试**不需要**模拟 env 函数抛出错误：

```typescript
// ❌ BAD - 在非 env 模块中测试环境变量缺失，职责不属于这里
mockedRedisUrl.mockImplementation(() => {
  throw new Error("Missing required environment variable: REDIS_URL");
});
expect(() => createRedisClient()).toThrow();

// ✅ GOOD - mock env 后只测试正常逻辑，env 校验交给 env.test.ts
mockedRedisUrl.mockReturnValue("https://redis.upstash.io");
mockedRedisToken.mockReturnValue("test-token-123");
const client = createRedisClient();
expect(client).toBeDefined();
```

### vi.resetModules() 使用规范

**仅在必要时**调用 `vi.resetModules()`，避免过度使用导致内存泄漏：

```typescript
// ❌ BAD - 过度使用 resetModules，导致模块重复加载
beforeEach(() => {
  vi.resetModules(); // 每次测试都重置
});

afterEach(() => {
  vi.resetModules(); // 每次测试后也重置
});

test("test 1", async () => {
  vi.resetModules(); // 测试内部又重置
  const module = await import("./module");
});

// ✅ GOOD - 只在需要动态 import 并改变模块行为时重置
test("should use different config", async () => {
  vi.resetModules();
  vi.mock("@/help/env", () => ({
    LOG_LEVEL: () => "debug",
  }));
  const module = await import("./module");
  // ...
});
```

### 使用 try-finally 确保清理

修改全局对象时，使用 `try-finally` 确保即使测试失败也能恢复：

```typescript
// ❌ BAD - 测试失败时不会恢复
test("should work", () => {
  const originalRequire = require;
  global.require = mockRequire;
  // 如果这里抛出异常，require 不会被恢复
  doSomething();
  global.require = originalRequire;
});

// ✅ GOOD - 使用 try-finally 确保恢复
test("should work", () => {
  const originalRequire = require;
  global.require = mockRequire;
  try {
    doSomething();
  } finally {
    // 无论测试成功或失败，都会恢复
    global.require = originalRequire;
  }
});
```

### 全局清理逻辑

在 `test/setup.ts` 中添加全局 `afterEach` 钩子，确保所有测试后都清理：

```typescript
// test/setup.ts
import { vi, afterEach } from "vitest";

// 全局清理，防止内存泄漏
afterEach(() => {
  // 清理所有定时器
  vi.clearAllTimers();
  
  // 注意：vi.restoreAllMocks() 由各个测试文件调用
  // 这里不调用，避免干扰测试特定的清理逻辑
});
```

### 检查清单

编写测试时，确保：

- [ ] 修改的全局对象在 `afterEach` 中恢复
- [ ] 环境变量通过 `vi.mock("@/help/env")` mock，而非 `vi.stubEnv()`
- [ ] 仅测试 `env.ts` 本身时才使用 `vi.stubEnv()`
- [ ] `vi.resetModules()` 只在必要时调用
- [ ] 修改全局对象时使用 `try-finally` 确保恢复
- [ ] 不在模块级别保存环境变量原始值
- [ ] 测试失败时也能正确清理资源
